

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>lingvo.core.layers module &mdash; Lingvo  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="lingvo.core.layers_with_attention module" href="lingvo.core.layers_with_attention.html" />
    <link rel="prev" title="lingvo.core.insertion module" href="lingvo.core.insertion.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Lingvo
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="lingvo.html">lingvo package</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="lingvo.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="lingvo.core.html">lingvo.core package</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="lingvo.core.html#subpackages">Subpackages</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="lingvo.core.html#submodules">Submodules</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="lingvo.tasks.html">lingvo.tasks package</a></li>
<li class="toctree-l3"><a class="reference internal" href="lingvo.tools.html">lingvo.tools package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="lingvo.html#submodules">Submodules</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Lingvo</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="lingvo.html">lingvo package</a> &raquo;</li>
        
          <li><a href="lingvo.core.html">lingvo.core package</a> &raquo;</li>
        
      <li>lingvo.core.layers module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/lingvo.core.layers.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-lingvo.core.layers">
<span id="lingvo-core-layers-module"></span><h1>lingvo.core.layers module<a class="headerlink" href="#module-lingvo.core.layers" title="Permalink to this headline">¶</a></h1>
<p>Common layers.</p>
<dl class="function">
<dt id="lingvo.core.layers.Gelu">
<code class="descclassname">lingvo.core.layers.</code><code class="descname">Gelu</code><span class="sig-paren">(</span><em>input_tensor</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#Gelu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.Gelu" title="Permalink to this definition">¶</a></dt>
<dd><p>Gaussian Error Linear Unit.</p>
<p>This is a smoother version of the RELU.
Original paper: <a class="reference external" href="https://arxiv.org/abs/1606.08415">https://arxiv.org/abs/1606.08415</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>input_tensor</strong> – float Tensor to perform activation.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><code class="xref py py-obj docutils literal notranslate"><span class="pre">input_tensor</span></code> with the GELU activation applied.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.IdentityLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">IdentityLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#IdentityLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.IdentityLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Identity layer, adds name and propagates its input.</p>
<dl class="method">
<dt id="lingvo.core.layers.IdentityLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#IdentityLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.IdentityLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity mapping.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>inputs</strong> – The inputs tensor.  Shaped […, input_dim].</li>
<li><strong>*args</strong> – Arguments to be ignored.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Tensor with the same shape and type of inputs.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="lingvo.core.layers.IdentityLayer.FPropMeta">
<em class="property">classmethod </em><code class="descname">FPropMeta</code><span class="sig-paren">(</span><em>p</em>, <em>inputs</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#IdentityLayer.FPropMeta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.IdentityLayer.FPropMeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns metadata about the <a class="reference internal" href="#lingvo.core.layers.IdentityLayer.FProp" title="lingvo.core.layers.IdentityLayer.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> computation for this layer.</p>
<p><strong>Experimental feature.</strong>
Don’t use or depend on it without consulting Lingvo authors.</p>
<p>E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">SomeComplexLayer</span><span class="o">.</span><span class="n">Params</span><span class="p">()</span>
<span class="n">meta</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="n">FPropMeta</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tshape</span><span class="o">.</span><span class="n">Shape</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">&#39;channels&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">meta.flops</span></code> gives an estimate count of floating point operations done by
one <a class="reference internal" href="#lingvo.core.layers.IdentityLayer.FProp" title="lingvo.core.layers.IdentityLayer.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> given an input tensor of shape [128, 20, 50, channels].
<code class="xref py py-obj docutils literal notranslate"><span class="pre">meta.out_shapes</span></code> is a tuple of TShape, which tells you what shape
of tensors this layer will return.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>params</strong> – The param of a layer of this layer type.</li>
<li><strong>*args</strong> – Corresponds to FProp with Tensors replaced by <code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorShape</span></code>.</li>
<li><strong>**kwargs</strong> – Corresponds to FProp with Tensors replaced by <code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorShape</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> with</p>
<ul class="simple">
<li>flops - The estimated number of floating point operations incurred by
this fprop.</li>
<li>out_shapes - A tuple of <code class="xref py py-obj docutils literal notranslate"><span class="pre">TShape</span></code>. I.e., <code class="xref py py-obj docutils literal notranslate"><span class="pre">out_shapes[i]</span></code>
represents the shape of the <code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code>-th returned tensor of the fprop.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.BaseConv2DLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">BaseConv2DLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#BaseConv2DLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.BaseConv2DLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.quant_utils.html#lingvo.core.quant_utils.QuantizableLayer" title="lingvo.core.quant_utils.QuantizableLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.quant_utils.QuantizableLayer</span></code></a></p>
<p>Base class for 2D convolution layers.</p>
<p>Has support for optional batch-normalization, activation and sequence
padding.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.BaseConv2DLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#BaseConv2DLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.BaseConv2DLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.BaseConv2DLayer.output_channels">
<code class="descname">output_channels</code><a class="headerlink" href="#lingvo.core.layers.BaseConv2DLayer.output_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of output channels for this conv layer.</p>
</dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.BaseConv2DLayer.filter_output_shape">
<code class="descname">filter_output_shape</code><a class="headerlink" href="#lingvo.core.layers.BaseConv2DLayer.filter_output_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Final dims of the filter corresponding to the output channels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A one (standard conv) or two (depthwise conv) element shape representing
the final dimensions of the filter weights that are output channel
specific for this layer. This shape is needed for any arithmetic that
needs to convert between a linear list of filter weights and the
arrangement in the actual filter.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.BaseConv2DLayer._is_bn_folded">
<code class="descname">_is_bn_folded</code><a class="headerlink" href="#lingvo.core.layers.BaseConv2DLayer._is_bn_folded" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether batchnorm folded weights are effectively enabled.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.BaseConv2DLayer._EvaluateConvKernel">
<code class="descname">_EvaluateConvKernel</code><span class="sig-paren">(</span><em>inputs</em>, <em>filter_w</em>, <em>strides</em>, <em>dilation_rate</em>, <em>padding_algorithm</em>, <em>data_format</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#BaseConv2DLayer._EvaluateConvKernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.BaseConv2DLayer._EvaluateConvKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the lower level convolution kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputs</strong> – As to tf.nn.convolution.</li>
<li><strong>filter_w</strong> – As to tf.nn.depthwise_conv2d.</li>
<li><strong>strides</strong> – As to tf.nn.convolution.</li>
<li><strong>dilation_rate</strong> – As to tf.nn.convolution.</li>
<li><strong>padding_algorithm</strong> – As to tf.nn.convolution (padding argument).</li>
<li><strong>data_format</strong> – As to tf.nn.convolution.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Convolution kernel output.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.BaseConv2DLayer.OutShape">
<code class="descname">OutShape</code><span class="sig-paren">(</span><em>in_shape</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#BaseConv2DLayer.OutShape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.BaseConv2DLayer.OutShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the output shape given the input shape.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.BaseConv2DLayer._GetWeights">
<code class="descname">_GetWeights</code><span class="sig-paren">(</span><em>theta</em>, <em>convolution_lambda</em>, <em>folded_bn_padding</em>, <em>cast_dtype=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#BaseConv2DLayer._GetWeights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.BaseConv2DLayer._GetWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a dictionary of weights and biases for the convolution.</p>
<p>This is necessary for some operating modes where the weights are fused
with batch normalization differently for training vs eval.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing underlying weights values of this
layer and its children layers.</li>
<li><strong>convolution_lambda</strong> – Lambda which takes the convolution weights and runs
the convolution.</li>
<li><strong>folded_bn_padding</strong> – Padding to apply to folded batch normalization moment
computation (or None for no padding).</li>
<li><strong>cast_dtype</strong> – If not None, cast weights to the given dtype.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Tuple of (filter, biases).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.BaseConv2DLayer._ApplyConv">
<code class="descname">_ApplyConv</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>folded_bn_padding=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#BaseConv2DLayer._ApplyConv"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.BaseConv2DLayer._ApplyConv" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.BaseConv2DLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>paddings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#BaseConv2DLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.BaseConv2DLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply convolution to inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>inputs</strong> – The inputs tensor. It is expected to be of shape [batch, time,
frequency, channel]. The time dimension corresponds to the height
dimension as in images and the frequency dimension corresponds to the
width dimension as in images.</li>
<li><strong>paddings</strong> – The paddings tensor. If None, the inputs have no paddings in the
sense of sequence training (e.g., in CNN models). Otherwise, it is
expected to be of shape [batch, time].</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">outputs, out_paddings pair.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.BaseConv2DLayer._Compute">
<code class="descname">_Compute</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>paddings</em>, <em>conv_padding</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#BaseConv2DLayer._Compute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.BaseConv2DLayer._Compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the forward prop (conv, bn, act).</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.BaseConv2DLayer._ComputeConvLast">
<code class="descname">_ComputeConvLast</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>paddings</em>, <em>conv_padding</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#BaseConv2DLayer._ComputeConvLast"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.BaseConv2DLayer._ComputeConvLast" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the forward prop in conv_last mode (bn, act, conv).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.Conv2DLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">Conv2DLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#Conv2DLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.Conv2DLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingvo.core.layers.BaseConv2DLayer" title="lingvo.core.layers.BaseConv2DLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.layers.BaseConv2DLayer</span></code></a></p>
<p>Convolution layer, with optional batch-normalization and activation.</p>
<dl class="method">
<dt id="lingvo.core.layers.Conv2DLayer._EvaluateConvKernel">
<code class="descname">_EvaluateConvKernel</code><span class="sig-paren">(</span><em>inputs</em>, <em>filter_w</em>, <em>strides</em>, <em>dilation_rate</em>, <em>padding_algorithm</em>, <em>data_format</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#Conv2DLayer._EvaluateConvKernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.Conv2DLayer._EvaluateConvKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the lower level convolution kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputs</strong> – As to tf.nn.convolution.</li>
<li><strong>filter_w</strong> – As to tf.nn.depthwise_conv2d.</li>
<li><strong>strides</strong> – As to tf.nn.convolution.</li>
<li><strong>dilation_rate</strong> – As to tf.nn.convolution.</li>
<li><strong>padding_algorithm</strong> – As to tf.nn.convolution (padding argument).</li>
<li><strong>data_format</strong> – As to tf.nn.convolution.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Convolution kernel output.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.ConvLayer">
<code class="descclassname">lingvo.core.layers.</code><code class="descname">ConvLayer</code><a class="headerlink" href="#lingvo.core.layers.ConvLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#lingvo.core.layers.Conv2DLayer" title="lingvo.core.layers.Conv2DLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.layers.Conv2DLayer</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.DepthwiseConv2DLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">DepthwiseConv2DLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#DepthwiseConv2DLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.DepthwiseConv2DLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingvo.core.layers.BaseConv2DLayer" title="lingvo.core.layers.BaseConv2DLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.layers.BaseConv2DLayer</span></code></a></p>
<p>Depthwise conv 2D layer.</p>
<p>paper: <a class="reference external" href="https://arxiv.org/abs/1610.02357">https://arxiv.org/abs/1610.02357</a></p>
<dl class="classmethod">
<dt id="lingvo.core.layers.DepthwiseConv2DLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#DepthwiseConv2DLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.DepthwiseConv2DLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.DepthwiseConv2DLayer.output_channels">
<code class="descname">output_channels</code><a class="headerlink" href="#lingvo.core.layers.DepthwiseConv2DLayer.output_channels" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of output channels for this conv layer.</p>
</dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.DepthwiseConv2DLayer.filter_output_shape">
<code class="descname">filter_output_shape</code><a class="headerlink" href="#lingvo.core.layers.DepthwiseConv2DLayer.filter_output_shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Final dims of the filter corresponding to the output channels.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.DepthwiseConv2DLayer._EvaluateConvKernel">
<code class="descname">_EvaluateConvKernel</code><span class="sig-paren">(</span><em>inputs</em>, <em>filter_w</em>, <em>strides</em>, <em>dilation_rate</em>, <em>padding_algorithm</em>, <em>data_format</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#DepthwiseConv2DLayer._EvaluateConvKernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.DepthwiseConv2DLayer._EvaluateConvKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the lower level convolution kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputs</strong> – As to tf.nn.convolution.</li>
<li><strong>filter_w</strong> – As to tf.nn.depthwise_conv2d.</li>
<li><strong>strides</strong> – As to tf.nn.convolution.</li>
<li><strong>dilation_rate</strong> – As to tf.nn.convolution.</li>
<li><strong>padding_algorithm</strong> – As to tf.nn.convolution (padding argument).</li>
<li><strong>data_format</strong> – As to tf.nn.convolution.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Convolution kernel output.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.SeparableConv2DLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">SeparableConv2DLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SeparableConv2DLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SeparableConv2DLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingvo.core.layers.Conv2DLayer" title="lingvo.core.layers.Conv2DLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.layers.Conv2DLayer</span></code></a></p>
<p>Separable 2D convolution.</p>
<p>This class aggregates a DepthwiseConv2DLayer that feeds in to the point
wise convolution defined by this layer. Since the point wise convolution
controls the output, this class is defined in terms of that and delegates
to a depthwise sub-layer.</p>
<dl class="docutils">
<dt>The <code class="xref py py-obj docutils literal notranslate"><span class="pre">filter_shape</span></code> parameter is rewritten on initialization from the form:</dt>
<dd>(h, w, cin, cout)</dd>
<dt>To:</dt>
<dd>Depthwise filter: (h, w, cin, p.depth_multiplier)
Pointwise filter (on this instance): (1, 1, cin * p.depth_multiplier, cout)</dd>
</dl>
<p>This way, the layer is configured as if it were a normal 2D convolution
but is internally reconfigured to be separable.</p>
<p>paper: <a class="reference external" href="https://arxiv.org/abs/1610.02357">https://arxiv.org/abs/1610.02357</a></p>
<dl class="classmethod">
<dt id="lingvo.core.layers.SeparableConv2DLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SeparableConv2DLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SeparableConv2DLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SeparableConv2DLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>paddings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SeparableConv2DLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SeparableConv2DLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply convolution to inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>inputs</strong> – The inputs tensor. It is expected to be of shape [batch, time,
frequency, channel]. The time dimension corresponds to the height
dimension as in images and the frequency dimension corresponds to the
width dimension as in images.</li>
<li><strong>paddings</strong> – The paddings tensor. If None, the inputs have no paddings in the
sense of sequence training (e.g., in CNN models). Otherwise, it is
expected to be of shape [batch, time].</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">outputs, out_paddings pair.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SeparableConv2DLayer.OutShape">
<code class="descname">OutShape</code><span class="sig-paren">(</span><em>in_shape</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SeparableConv2DLayer.OutShape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SeparableConv2DLayer.OutShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the output shape given the input shape.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.ProjectionLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">ProjectionLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ProjectionLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ProjectionLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.quant_utils.html#lingvo.core.quant_utils.QuantizableLayer" title="lingvo.core.quant_utils.QuantizableLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.quant_utils.QuantizableLayer</span></code></a></p>
<p>Projection layer, with batch normalization and relu activation.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.ProjectionLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ProjectionLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ProjectionLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.ProjectionLayer.output_qt_name">
<code class="descname">output_qt_name</code><a class="headerlink" href="#lingvo.core.layers.ProjectionLayer.output_qt_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of QTensor used for the output value.</p>
<p>Useful for grabbing the quantization of the output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">String name of output qtensor.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.ProjectionLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>paddings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ProjectionLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ProjectionLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply projection to inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>inputs</strong> – The inputs tensor.  Shaped […, input_dim].</li>
<li><strong>paddings</strong> – The paddings tensor.  Shaped […, 1], where all but the last
dimension match.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Output after applying projection, and optionally batch normalization and
relu non-linearity.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.ProjectionLayer._is_bn_folded">
<code class="descname">_is_bn_folded</code><a class="headerlink" href="#lingvo.core.layers.ProjectionLayer._is_bn_folded" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether batchnorm folded weights are effectively enabled.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.ProjectionLayer._GetWeights">
<code class="descname">_GetWeights</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>paddings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ProjectionLayer._GetWeights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ProjectionLayer._GetWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the weights for the computation.</p>
<p>Weights will always have weight_norm applied and may have batch_norm
folded if enabled.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>inputs</strong> – Inputs (needed for batchnorm folding).</li>
<li><strong>paddings</strong> – Paddings (needed for batchnorm folding).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Tuple of (w, b) to use for the forward pass. b may be None if bias is
disabled.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.ProjectionLayer._ApplyProjectionKernel">
<code class="descname">_ApplyProjectionKernel</code><span class="sig-paren">(</span><em>w</em>, <em>b</em>, <em>inputs</em>, <em>with_activation=True</em>, <em>quant=False</em>, <em>bn=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ProjectionLayer._ApplyProjectionKernel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ProjectionLayer._ApplyProjectionKernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies matmul/bias/activation in one step.</p>
<p>Note that it is important that these three ops be computed in this way as
downstream inference engines (esp. for quantized inference) can recognize
and fuse them. For floating point, this is an optimization, but for
quantization, it is required.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>w</strong> – Weight matrix.</li>
<li><strong>b</strong> – Bias vector (or None).</li>
<li><strong>inputs</strong> – FProp inputs.</li>
<li><strong>with_activation</strong> – Whether to also compute the activation function.</li>
<li><strong>quant</strong> – Whether to apply quantization.</li>
<li><strong>bn</strong> – Apply batchnorm.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Output tensor reshaped.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.StackingOverTime">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">StackingOverTime</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#StackingOverTime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.StackingOverTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Stacking applied along the time axis.</p>
<p>At each time step of an input sequence, elements are stacked over the
window of (‘left_context’ + 1 + ‘right_context’) steps around the current
time step. Zeros will be padded to the left or right of the sequence for
elements around the boundaries. Finally the stacked outputs are emitted
once every ‘stride’ steps.</p>
<p>E.g. if an input sequence is: [4], [1], [9], [3], [5], [2], [8]
left_context = 1, right_context = 1, stride = 3,
then the output sequence would be: [0, 4, 1], [9, 3, 5], [2, 8, 0]</p>
<p>Note that this layer only performs tensor transformation, so there are no
learnable parameters.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.StackingOverTime.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#StackingOverTime.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.StackingOverTime.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.StackingOverTime.window_size">
<code class="descname">window_size</code><a class="headerlink" href="#lingvo.core.layers.StackingOverTime.window_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the stacking window size.</p>
<p>The output dimension will be window_size * the input dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Window size.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.StackingOverTime._ApplyStack">
<code class="descname">_ApplyStack</code><span class="sig-paren">(</span><em>inputs</em>, <em>pad_value=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#StackingOverTime._ApplyStack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.StackingOverTime._ApplyStack" title="Permalink to this definition">¶</a></dt>
<dd><p>The core function to apply the stacking to inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputs</strong> – [batch, time, depth].</li>
<li><strong>pad_value</strong> – the padding value for left/right context.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">[batch, ceil(time / stride), depth * stacking_window_length].</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">out</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.StackingOverTime.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>inputs</em>, <em>paddings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#StackingOverTime.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.StackingOverTime.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the stacking to inputs along the time axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputs</strong> – The inputs tensor. It is expected to be of shape [batch, time,
feature].</li>
<li><strong>paddings</strong> – The paddings tensor. It is expected to be of shape [batch, time,
1], where all but the last dimension match those of inputs. Each value
is 0 or 1 indicating whether a time step of a sequence is padded in the
inputs to reach the max length in the batch.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><dl class="docutils">
<dt>(outputs, out_paddings) pair.</dt>
<dd><p class="first last">outputs is of shape [batch, ceil(time / stride), feature * stacking].
out_paddings is of shape [batch, ceil(time / stride), 1]. out_paddings
will be 0 if any of the corresponding input padding is 0.</p>
</dd>
</dl>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.StackingOverTime.Unstack">
<code class="descname">Unstack</code><span class="sig-paren">(</span><em>stacked</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#StackingOverTime.Unstack"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.StackingOverTime.Unstack" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverts stacking over time.</p>
<p>Given ‘stacked’ outputs from this StackingOverTime layer,</p>
<blockquote>
<div>stacked = this_layer.FProp(inputs),</div></blockquote>
<p>this method attempts to reconstruct the original ‘inputs’. If
stride &lt;= window_size, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Unstack(stacked)</span></code> returns a Tensor that is identical
to ‘inputs’ but up to stride - 1 frames shorter in the time axis. If
stride &gt; window_size, the original input cannot be recovered, and a
ValueError is raised.</p>
<p><a class="reference internal" href="#lingvo.core.layers.StackingOverTime.Unstack" title="lingvo.core.layers.StackingOverTime.Unstack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Unstack()</span></code></a> can also be used to project the outputs of downstream layers
back to the original unstacked inputs. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">inputs</span> <span class="o">=</span> <span class="o">...</span>  <span class="c1"># [batch, length, input_dim]</span>
<span class="c1"># [batch, ceil(length / stride), rnn_dim]</span>
<span class="n">rnn_out</span> <span class="o">=</span> <span class="n">rnn</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">stacking</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span>
<span class="c1"># [batch, length, rnn_dim]</span>
<span class="n">back_projected_rnn_out</span> <span class="o">=</span> <span class="n">py_utils</span><span class="o">.</span><span class="n">PadOrTrimTo</span><span class="p">(</span>
    <span class="n">stacking</span><span class="o">.</span><span class="n">Unstack</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">rnn_out</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stacking</span><span class="o">.</span><span class="n">window_size</span><span class="p">])),</span>
    <span class="n">tf</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span>
</pre></div>
</div>
<p>Note this method does not take or return a separate padding tensor. The
caller is responsible for knowing which of outputs are padding (e.g. based
on the padding of the original FProp inputs).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>stacked</strong> – Tensor of shape [batch, time, window_size * feature_dim], assumed
to be the output of <a class="reference internal" href="#lingvo.core.layers.StackingOverTime.FProp" title="lingvo.core.layers.StackingOverTime.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The reconstructed (but truncated) input Tensor, with shape
[batch, L - (L - 1) % stride, feature_dim] where L is the length of the
original inputs. The length of the returned Tensor is also, equivalently,
(stacked_length - 1) * stride + 1.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ValueError</span></code> – if stride &gt; window_size.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.FCLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">FCLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#FCLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.FCLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingvo.core.layers.ProjectionLayer" title="lingvo.core.layers.ProjectionLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.layers.ProjectionLayer</span></code></a></p>
<p>Fully-connected layer (matmul + bias + optional activation).</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.FCLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#FCLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.FCLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.PoolingLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">PoolingLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#PoolingLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.PoolingLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.quant_utils.html#lingvo.core.quant_utils.QuantizableLayer" title="lingvo.core.quant_utils.QuantizableLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.quant_utils.QuantizableLayer</span></code></a></p>
<p>Pooling layer, by default performs max-pooling.</p>
<p>Quantization notes: Unlike the common pattern, the pooling layer inputs
and output must be quantized to the same range, so it tracks both (vs
just the output). The preceding layer must have its output quantization
disabled.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.PoolingLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#PoolingLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.PoolingLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.PoolingLayer.OutShape">
<code class="descname">OutShape</code><span class="sig-paren">(</span><em>in_shape</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#PoolingLayer.OutShape"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.PoolingLayer.OutShape" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the output shape given the input shape.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.PoolingLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>paddings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#PoolingLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.PoolingLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply pooling to inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>inputs</strong> – The inputs tensor. It is expected to be of shape [batch, time,
frequency, channel]. The time dimension corresponds to the height
dimension as in images and the frequency dimension corresponds to the
width dimension as in images.</li>
<li><strong>paddings</strong> – The paddings tensor. It is expected to be of shape [batch,
time]. Defaults to None, which means there no paddings.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">outputs, out_paddings pair.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.EmbeddingLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">EmbeddingLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#EmbeddingLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.EmbeddingLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Embedding layer.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.EmbeddingLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#EmbeddingLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.EmbeddingLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.EmbeddingLayer.MIN_PARAMS_PER_SHARD">
<code class="descname">MIN_PARAMS_PER_SHARD</code><em class="property"> = 262144</em><a class="headerlink" href="#lingvo.core.layers.EmbeddingLayer.MIN_PARAMS_PER_SHARD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.EmbeddingLayer.vars">
<code class="descname">vars</code><a class="headerlink" href="#lingvo.core.layers.EmbeddingLayer.vars" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.EmbeddingLayer.theta">
<code class="descname">theta</code><a class="headerlink" href="#lingvo.core.layers.EmbeddingLayer.theta" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.EmbeddingLayer.EmbLookupDefaultTheta">
<code class="descname">EmbLookupDefaultTheta</code><span class="sig-paren">(</span><em>ids</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#EmbeddingLayer.EmbLookupDefaultTheta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.EmbeddingLayer.EmbLookupDefaultTheta" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.EmbeddingLayer.EmbLookup">
<code class="descname">EmbLookup</code><span class="sig-paren">(</span><em>theta</em>, <em>ids</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#EmbeddingLayer.EmbLookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.EmbeddingLayer.EmbLookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Looks up embedding vectors for ids.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – Named tuple with the weight matrix for the embedding.</li>
<li><strong>ids</strong> – A rank-N int32 tensor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A rank-(N+1) params.dtype tensor.
embs[indices, :] is the embedding vector for ids[indices].</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.TPUEmbeddingTable">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">TPUEmbeddingTable</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#TPUEmbeddingTable"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.TPUEmbeddingTable" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>An embedding table controlled by TPUEmbeddingLayer.</p>
<p>Note that all input_keys needs to be declared upfront.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.TPUEmbeddingTable.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#TPUEmbeddingTable.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.TPUEmbeddingTable.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.TPUEmbeddingTable.table_config">
<code class="descname">table_config</code><a class="headerlink" href="#lingvo.core.layers.TPUEmbeddingTable.table_config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.TPUEmbeddingTable.table_name">
<code class="descname">table_name</code><a class="headerlink" href="#lingvo.core.layers.TPUEmbeddingTable.table_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.TPUEmbeddingTable.retrieve_op_list">
<code class="descname">retrieve_op_list</code><a class="headerlink" href="#lingvo.core.layers.TPUEmbeddingTable.retrieve_op_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.TPUEmbeddingTable.load_op_list">
<code class="descname">load_op_list</code><a class="headerlink" href="#lingvo.core.layers.TPUEmbeddingTable.load_op_list" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.TPUEmbeddingTable.input_keys">
<code class="descname">input_keys</code><a class="headerlink" href="#lingvo.core.layers.TPUEmbeddingTable.input_keys" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.TPUEmbeddingTable.max_sequence_length">
<code class="descname">max_sequence_length</code><a class="headerlink" href="#lingvo.core.layers.TPUEmbeddingTable.max_sequence_length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.TPUEmbeddingTable.CpuEmbLookup">
<code class="descname">CpuEmbLookup</code><span class="sig-paren">(</span><em>ids_map</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#TPUEmbeddingTable.CpuEmbLookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.TPUEmbeddingTable.CpuEmbLookup" title="Permalink to this definition">¶</a></dt>
<dd><p>CPU evaluation embedding lookup.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ids_map</strong> – A dict of <code class="xref py py-obj docutils literal notranslate"><span class="pre">input_key</span></code> string -&gt; [batch, sequence] int32 Tensor.
-1 is used as a padding id.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">An activations dict of string -&gt; float32 Tensor.
For non-sequence embeddings: [batch, 1, embedding_dim]
For sequence embeddings: [batch, max_sequence_length, embedding_dim]</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.TPUEmbeddingLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">TPUEmbeddingLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#TPUEmbeddingLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.TPUEmbeddingLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Monolithic interface to TPU embedding.</p>
<p>This layer has some important caveats, due to the interface of the
TPU embedding hardware. Its behavior most closely mimics that of
tf.nn.embedding_lookup_sparse.</p>
<p>Supports multiple tables and multiple input_keys per table.
Only supports Adagrad.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.TPUEmbeddingLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#TPUEmbeddingLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.TPUEmbeddingLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.TPUEmbeddingLayer.EmbLookup">
<code class="descname">EmbLookup</code><span class="sig-paren">(</span><em>ids_map</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#TPUEmbeddingLayer.EmbLookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.TPUEmbeddingLayer.EmbLookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Looks up embedding vectors for each entry in ids_map.</p>
<p>Since the TPUEmbedding is monolothic, and consulted once per
FProp/BPRop, we must centralize the lookup. Thus, for multiple
features, we contain them into a single-lookup rather than allowing
the caller to call Lookup multiple times.</p>
<p>Currently, there’s also an implied combination step which combines
the sequence into a single set of activations by sum, mean or
sqrtn.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ids_map</strong> – A dict of <code class="xref py py-obj docutils literal notranslate"><span class="pre">input_key</span></code> string -&gt; [batch, sequence] int32 Tensor.
-1 is used as a padding id.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Activations dict of string -&gt;
For non-sequence embeddings:  [batch, 1, embedding_dim],
For sequence embeddings: [batch, max_sequence_length, embedding_dim]
float32 Tensor.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.SimpleEmbeddingLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">SimpleEmbeddingLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleEmbeddingLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleEmbeddingLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.quant_utils.html#lingvo.core.quant_utils.QuantizableLayer" title="lingvo.core.quant_utils.QuantizableLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.quant_utils.QuantizableLayer</span></code></a></p>
<p>An embedding layer that is simple to compile (by XLA and Toco).</p>
<p>The params use_matmul and use_gather control how the lookup is performed.
If neither is True, then a loop is used to compute the embedding.</p>
<p>This layer is “simple” in comparison to ‘EmbeddingLayer’ in that it does
not shard the embeddings.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.SimpleEmbeddingLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleEmbeddingLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleEmbeddingLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SimpleEmbeddingLayer.EmbLookupDefaultTheta">
<code class="descname">EmbLookupDefaultTheta</code><span class="sig-paren">(</span><em>ids</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleEmbeddingLayer.EmbLookupDefaultTheta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleEmbeddingLayer.EmbLookupDefaultTheta" title="Permalink to this definition">¶</a></dt>
<dd><p>Lookups embedding vectors for ids.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SimpleEmbeddingLayer.EmbLookup">
<code class="descname">EmbLookup</code><span class="sig-paren">(</span><em>theta</em>, <em>ids</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleEmbeddingLayer.EmbLookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleEmbeddingLayer.EmbLookup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SimpleEmbeddingLayer.EmbLookupDefaultThetaOnCpu">
<code class="descname">EmbLookupDefaultThetaOnCpu</code><span class="sig-paren">(</span><em>ids</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleEmbeddingLayer.EmbLookupDefaultThetaOnCpu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleEmbeddingLayer.EmbLookupDefaultThetaOnCpu" title="Permalink to this definition">¶</a></dt>
<dd><p>A faster path for CPU inference than the default gather.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SimpleEmbeddingLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>ids</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleEmbeddingLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleEmbeddingLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Lookups embedding vectors for ids.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – Named tuple collection of weights for the layer.</li>
<li><strong>ids</strong> – A rank-N int32 tensor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A rank-(N+1) params.dtype tensor.
embs[indices, :] is the embedding vector for ids[indices].</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.PositionalEmbeddingLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">PositionalEmbeddingLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#PositionalEmbeddingLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.PositionalEmbeddingLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Generates sinusoidals with respect to the position in time and dimension.</p>
<p>Implements the positional embedding layer from ‘Attention is All You Need’,
the Transformer Network.</p>
<p>Code and comments are adapted from tensor2tensor/layers/common_attention.py</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.PositionalEmbeddingLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#PositionalEmbeddingLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.PositionalEmbeddingLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.PositionalEmbeddingLayer._PosEmbeddingsFromPositions">
<code class="descname">_PosEmbeddingsFromPositions</code><span class="sig-paren">(</span><em>theta</em>, <em>position</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#PositionalEmbeddingLayer._PosEmbeddingsFromPositions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.PositionalEmbeddingLayer._PosEmbeddingsFromPositions" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the positional embeddings given the position tensor.</p>
<p>Factors out the common code from FProp and FPropWithPosition. Returns
positional embeddings corresponding to the input position tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>position</strong> – Position tensor of dtype float and shape [bs, seq_length] to
generate positional embeddings.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a Tensor of shape [bs, seq_length, embedding_dim].</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.PositionalEmbeddingLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>seq_length</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#PositionalEmbeddingLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.PositionalEmbeddingLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a Tensor of sinusoids with different frequencies.</p>
<p>Each channel (dimension) of the generated positionanl embedding Tensor
corresponds to a sinusoid of different frequency and phase.</p>
<p>This allows attention to learn to use absolute and relative positions.
Timing signals should be added to some precursors of both the query and the
memory inputs to attention.</p>
<p>The use of relative position is possible because sin(x+y) and cos(x+y) can
be experessed in terms of y, sin(x) and cos(x).</p>
<p>In particular, we use a geometric sequence of timescales starting with
min_timescale and ending with max_timescale.  The number of different
timescales is equal to channels (dimension) / 2. For each timescale, we
generate the two sinusoidal signals sin(timestep/timescale) and
cos(timestep/timescale).  All of these sinusoids are concatenated in
the channels dimension.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>seq_length</strong> – Sequence length of the embeddings to be generated</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a Tensor of shape [seq_length, embedding_dim].</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.PositionalEmbeddingLayer.FPropWithPosition">
<code class="descname">FPropWithPosition</code><span class="sig-paren">(</span><em>theta</em>, <em>position_tensor</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#PositionalEmbeddingLayer.FPropWithPosition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.PositionalEmbeddingLayer.FPropWithPosition" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a Tensor of sinusoids with different frequencies.</p>
<p>Uses the provided position tensor to generate positional embeddings. Refer
to FProp description for details of sinusoidal positional embeddings.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>position_tensor</strong> – Position tensor of shape [bs, seq_length] to generate
positional embeddings.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a Tensor of shape [bs, seq_length, embedding_dim].</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.SoftmaxLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">SoftmaxLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SoftmaxLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SoftmaxLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.quant_utils.html#lingvo.core.quant_utils.QuantizableLayer" title="lingvo.core.quant_utils.QuantizableLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.quant_utils.QuantizableLayer</span></code></a></p>
<p>Base class for softmax layers.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.SoftmaxLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SoftmaxLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SoftmaxLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Params for SoftmaxLayer.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SoftmaxLayer.Logits">
<code class="descname">Logits</code><span class="sig-paren">(</span><em>**unused</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SoftmaxLayer.Logits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SoftmaxLayer.Logits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the logits computed before the softmax.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SoftmaxLayer.XentLoss">
<code class="descname">XentLoss</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SoftmaxLayer.XentLoss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SoftmaxLayer.XentLoss" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes cross entropy.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SoftmaxLayer._FProp2D">
<code class="descname">_FProp2D</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>class_weights</em>, <em>class_ids=None</em>, <em>class_probabilities=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SoftmaxLayer._FProp2D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SoftmaxLayer._FProp2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Specialized FProp for matrix inputs.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SoftmaxLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>class_weights</em>, <em>class_ids=None</em>, <em>class_probabilities=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SoftmaxLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SoftmaxLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes logit, cross entropy etc.</p>
<p>This function can both work with class_ids, or probability distributions
over classes. Exactly one of class_ids or class_probabilities must be
provided.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>inputs</strong> – a list of a single tensor, or a single tensor with the shape […,
input_dim].</li>
<li><strong>class_weights</strong> – a tensor with shape […] containing the weights for each
target word.</li>
<li><strong>class_ids</strong> – a tensor with shape […, 1] of int32 dtype containing the
target class labels.</li>
<li><strong>class_probabilities</strong> – a tensor with shape […, num_classes] of float
values indicating class-membership probabilities.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> containing the following fields</p>
<ul class="simple">
<li>logits: with shape […, num_classes]. Unnormalized softmax’s logits.</li>
<li>per_example_argmax: with shape […]. argmax of i-th example.</li>
<li>per_example_xent: with shape […]. Cross entropy between i-th example’s
prediction and its label.</li>
<li>per_example_weight: with shape […]. class_weights casted to
this layer’s dtype.</li>
<li>total_xent: A scalar. The sum of per_example_weight * per_example_xent.</li>
<li>total_weight: A scalar. The sum of per_example_weight.</li>
<li>avg_xent: A scalar. total_loss / total_weight.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.SimpleFullSoftmax">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">SimpleFullSoftmax</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleFullSoftmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleFullSoftmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingvo.core.layers.SoftmaxLayer" title="lingvo.core.layers.SoftmaxLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.layers.SoftmaxLayer</span></code></a></p>
<p>A somewhat simple softmax layer.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.SimpleFullSoftmax.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleFullSoftmax.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleFullSoftmax.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Params for SimpleFullSoftmax.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SimpleFullSoftmax._GetInputs">
<code class="descname">_GetInputs</code><span class="sig-paren">(</span><em>inputs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleFullSoftmax._GetInputs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleFullSoftmax._GetInputs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SimpleFullSoftmax._ConcatWeights">
<code class="descname">_ConcatWeights</code><span class="sig-paren">(</span><em>theta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleFullSoftmax._ConcatWeights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleFullSoftmax._ConcatWeights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SimpleFullSoftmax._LogitsUsingConcatenatedWeights">
<code class="descname">_LogitsUsingConcatenatedWeights</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleFullSoftmax._LogitsUsingConcatenatedWeights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleFullSoftmax._LogitsUsingConcatenatedWeights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SimpleFullSoftmax.Logits">
<code class="descname">Logits</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleFullSoftmax.Logits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleFullSoftmax.Logits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the logits computed before the softmax.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>inputs</strong> – a list of a single tensor, or a single tensor with the shape [N,
input_dim].</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">logits [batch, num_classes]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SimpleFullSoftmax._XentLossByChunk">
<code class="descname">_XentLossByChunk</code><span class="sig-paren">(</span><em>theta</em>, <em>activation</em>, <em>class_ids</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleFullSoftmax._XentLossByChunk"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleFullSoftmax._XentLossByChunk" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes per-example xent loss between activation and class_ids.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.SimpleFullSoftmax._FProp2D">
<code class="descname">_FProp2D</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>class_weights</em>, <em>class_ids=None</em>, <em>class_probabilities=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#SimpleFullSoftmax._FProp2D"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.SimpleFullSoftmax._FProp2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes xent loss and log-prob logit.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.ConvSoftmax">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">ConvSoftmax</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ConvSoftmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ConvSoftmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.quant_utils.html#lingvo.core.quant_utils.QuantizableLayer" title="lingvo.core.quant_utils.QuantizableLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.quant_utils.QuantizableLayer</span></code></a></p>
<p>A softmax implementation based on 1x1 convolution.</p>
<p>On TPU this is much more memory efficient than MatMul after reshaping logits
to a matrix.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.ConvSoftmax.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ConvSoftmax.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ConvSoftmax.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Params for SoftmaxLayer.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.ConvSoftmax.Logits">
<code class="descname">Logits</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ConvSoftmax.Logits"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ConvSoftmax.Logits" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.FeedForwardNet">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">FeedForwardNet</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#FeedForwardNet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.FeedForwardNet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.quant_utils.html#lingvo.core.quant_utils.QuantizableLayer" title="lingvo.core.quant_utils.QuantizableLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.quant_utils.QuantizableLayer</span></code></a></p>
<p>A simple multiple layer feedforward network.</p>
<p>This class represents a stack of fully connected feedforward network. Each
layer in the network can be configured for whether or not to have batch-norm
applied to its output, its activation function, whether or not to apply
dropout to post-activation output.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.FeedForwardNet.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#FeedForwardNet.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.FeedForwardNet.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.FeedForwardNet.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>paddings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#FeedForwardNet.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.FeedForwardNet.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward propagation.</p>
<p>The central interface that subclasses should implement. The caller
calls <a class="reference internal" href="#lingvo.core.layers.FeedForwardNet.FProp" title="lingvo.core.layers.FeedForwardNet.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> with a <code class="xref py py-obj docutils literal notranslate"><span class="pre">theta</span></code> dictionary. E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span> <span class="o">=</span> <span class="n">InstanceOfASubClassOfFoo</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>The implementation of <a class="reference internal" href="#lingvo.core.layers.FeedForwardNet.FProp" title="lingvo.core.layers.FeedForwardNet.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp()</span></code></a> computes a function given
the theta and the inputs. E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">subs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
<span class="n">inputs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">a0</span> <span class="o">=</span> <span class="n">subs</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">linear</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">subs</span><span class="o">.</span><span class="n">softmax</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">softmax</span><span class="p">,</span> <span class="n">a0</span><span class="p">)</span>
<span class="c1"># The same layer applied twice.</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">subs</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">linear</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
<span class="k">return</span> <span class="n">a2</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this
layer and its children layers.</li>
<li><strong>*args</strong> – List args.</li>
<li><strong>**kwargs</strong> – Keyward args.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="lingvo.core.layers.FeedForwardNet.FPropMeta">
<em class="property">classmethod </em><code class="descname">FPropMeta</code><span class="sig-paren">(</span><em>p</em>, <em>inputs</em>, <em>paddings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#FeedForwardNet.FPropMeta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.FeedForwardNet.FPropMeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns metadata about the <a class="reference internal" href="#lingvo.core.layers.FeedForwardNet.FProp" title="lingvo.core.layers.FeedForwardNet.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> computation for this layer.</p>
<p><strong>Experimental feature.</strong>
Don’t use or depend on it without consulting Lingvo authors.</p>
<p>E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">SomeComplexLayer</span><span class="o">.</span><span class="n">Params</span><span class="p">()</span>
<span class="n">meta</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="n">FPropMeta</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tshape</span><span class="o">.</span><span class="n">Shape</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">&#39;channels&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">meta.flops</span></code> gives an estimate count of floating point operations done by
one <a class="reference internal" href="#lingvo.core.layers.FeedForwardNet.FProp" title="lingvo.core.layers.FeedForwardNet.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> given an input tensor of shape [128, 20, 50, channels].
<code class="xref py py-obj docutils literal notranslate"><span class="pre">meta.out_shapes</span></code> is a tuple of TShape, which tells you what shape
of tensors this layer will return.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>params</strong> – The param of a layer of this layer type.</li>
<li><strong>*args</strong> – Corresponds to FProp with Tensors replaced by <code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorShape</span></code>.</li>
<li><strong>**kwargs</strong> – Corresponds to FProp with Tensors replaced by <code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorShape</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> with</p>
<ul class="simple">
<li>flops - The estimated number of floating point operations incurred by
this fprop.</li>
<li>out_shapes - A tuple of <code class="xref py py-obj docutils literal notranslate"><span class="pre">TShape</span></code>. I.e., <code class="xref py py-obj docutils literal notranslate"><span class="pre">out_shapes[i]</span></code>
represents the shape of the <code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code>-th returned tensor of the fprop.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.DropoutLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">DropoutLayer</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#DropoutLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.DropoutLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Apply dropout during trainig.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.DropoutLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#DropoutLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.DropoutLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.DropoutLayer._Dropout">
<code class="descname">_Dropout</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>noise_shape</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#DropoutLayer._Dropout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.DropoutLayer._Dropout" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.DropoutLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#DropoutLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.DropoutLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply dropout to inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>inputs</strong> – The inputs tensor.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">inputs with dropout applied at training time.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="lingvo.core.layers.DropoutLayer.FPropMeta">
<em class="property">classmethod </em><code class="descname">FPropMeta</code><span class="sig-paren">(</span><em>p</em>, <em>inputs</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#DropoutLayer.FPropMeta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.DropoutLayer.FPropMeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns metadata about the <a class="reference internal" href="#lingvo.core.layers.DropoutLayer.FProp" title="lingvo.core.layers.DropoutLayer.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> computation for this layer.</p>
<p><strong>Experimental feature.</strong>
Don’t use or depend on it without consulting Lingvo authors.</p>
<p>E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">SomeComplexLayer</span><span class="o">.</span><span class="n">Params</span><span class="p">()</span>
<span class="n">meta</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="n">FPropMeta</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tshape</span><span class="o">.</span><span class="n">Shape</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">&#39;channels&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">meta.flops</span></code> gives an estimate count of floating point operations done by
one <a class="reference internal" href="#lingvo.core.layers.DropoutLayer.FProp" title="lingvo.core.layers.DropoutLayer.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> given an input tensor of shape [128, 20, 50, channels].
<code class="xref py py-obj docutils literal notranslate"><span class="pre">meta.out_shapes</span></code> is a tuple of TShape, which tells you what shape
of tensors this layer will return.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>params</strong> – The param of a layer of this layer type.</li>
<li><strong>*args</strong> – Corresponds to FProp with Tensors replaced by <code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorShape</span></code>.</li>
<li><strong>**kwargs</strong> – Corresponds to FProp with Tensors replaced by <code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorShape</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> with</p>
<ul class="simple">
<li>flops - The estimated number of floating point operations incurred by
this fprop.</li>
<li>out_shapes - A tuple of <code class="xref py py-obj docutils literal notranslate"><span class="pre">TShape</span></code>. I.e., <code class="xref py py-obj docutils literal notranslate"><span class="pre">out_shapes[i]</span></code>
represents the shape of the <code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code>-th returned tensor of the fprop.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.DeterministicDropoutLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">DeterministicDropoutLayer</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#DeterministicDropoutLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.DeterministicDropoutLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#lingvo.core.layers.DropoutLayer" title="lingvo.core.layers.DropoutLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.layers.DropoutLayer</span></code></a></p>
<p>Apply dropout during trainig.</p>
<dl class="method">
<dt id="lingvo.core.layers.DeterministicDropoutLayer._Dropout">
<code class="descname">_Dropout</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>noise_shape</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#DeterministicDropoutLayer._Dropout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.DeterministicDropoutLayer._Dropout" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.LayerNorm">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">LayerNorm</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#LayerNorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.LayerNorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Layer normalization.</p>
<p>Implements layer normalization:
<a class="reference external" href="https://arxiv.org/abs/1607.06450">https://arxiv.org/abs/1607.06450</a></p>
<dl class="classmethod">
<dt id="lingvo.core.layers.LayerNorm.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#LayerNorm.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.LayerNorm.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.LayerNorm.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#LayerNorm.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.LayerNorm.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies normalization over the last dimension (layer).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>inputs</strong> – A tensor of shape […, hidden_dim].</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">tensor of the same shape with inputs</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="lingvo.core.layers.LayerNorm.FPropMeta">
<em class="property">classmethod </em><code class="descname">FPropMeta</code><span class="sig-paren">(</span><em>p</em>, <em>inputs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#LayerNorm.FPropMeta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.LayerNorm.FPropMeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns metadata about the <a class="reference internal" href="#lingvo.core.layers.LayerNorm.FProp" title="lingvo.core.layers.LayerNorm.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> computation for this layer.</p>
<p><strong>Experimental feature.</strong>
Don’t use or depend on it without consulting Lingvo authors.</p>
<p>E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">SomeComplexLayer</span><span class="o">.</span><span class="n">Params</span><span class="p">()</span>
<span class="n">meta</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="n">FPropMeta</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tshape</span><span class="o">.</span><span class="n">Shape</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">&#39;channels&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">meta.flops</span></code> gives an estimate count of floating point operations done by
one <a class="reference internal" href="#lingvo.core.layers.LayerNorm.FProp" title="lingvo.core.layers.LayerNorm.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> given an input tensor of shape [128, 20, 50, channels].
<code class="xref py py-obj docutils literal notranslate"><span class="pre">meta.out_shapes</span></code> is a tuple of TShape, which tells you what shape
of tensors this layer will return.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>params</strong> – The param of a layer of this layer type.</li>
<li><strong>*args</strong> – Corresponds to FProp with Tensors replaced by <code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorShape</span></code>.</li>
<li><strong>**kwargs</strong> – Corresponds to FProp with Tensors replaced by <code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorShape</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> with</p>
<ul class="simple">
<li>flops - The estimated number of floating point operations incurred by
this fprop.</li>
<li>out_shapes - A tuple of <code class="xref py py-obj docutils literal notranslate"><span class="pre">TShape</span></code>. I.e., <code class="xref py py-obj docutils literal notranslate"><span class="pre">out_shapes[i]</span></code>
represents the shape of the <code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code>-th returned tensor of the fprop.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.ConvSetLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">ConvSetLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ConvSetLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ConvSetLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.quant_utils.html#lingvo.core.quant_utils.QuantizableLayer" title="lingvo.core.quant_utils.QuantizableLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.quant_utils.QuantizableLayer</span></code></a></p>
<p>Set of Convolutions with different filter sizes in a single layer.</p>
<p>Applies a set of convolutions with different filter shapes to the inputs and
returns the concatenated outputs.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.ConvSetLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ConvSetLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ConvSetLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.ConvSetLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>paddings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ConvSetLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ConvSetLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply all convolution sets to inputs and concatenate outputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>inputs</strong> – The inputs tensor. It is expected to be of shape [batch, time,
frequency, channel]. The time dimension corresponds to the height
dimension as in images and the frequency dimension corresponds to the
width dimension as in images.</li>
<li><strong>paddings</strong> – The paddings tensor. It is expected to be of shape [batch,
time].</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>A tuple (out, output_paddings).</p>
<ul class="simple">
<li>out: output tensor. Expected to be of shape [batch, time_mod,
frequency_mod, out_channel_1 + out_channel_2 …] where time_mod and
frequency_mod depend on the conv layer strides and out_channel_i is
the output channel size of the i-th conv layer in the set.</li>
<li>output_paddings: Modified paddings generated within <code class="xref py py-obj docutils literal notranslate"><span class="pre">ConvLayer.FProp</span></code>.
Expected to be of the shape [batch, time_mod].</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.LocalizedLabelSmoother">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">LocalizedLabelSmoother</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#LocalizedLabelSmoother"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.LocalizedLabelSmoother" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Smooths labels given as class ids.</p>
<p>Implements the smoothing from <a class="reference external" href="https://arxiv.org/abs/1612.02695">https://arxiv.org/abs/1612.02695</a>. Instead of
1-hot class ids the model is trained to predict a distribution over classes
that includes the correct class label and with a small probability the labels
of tokens that appear nearby in time in the ground truth. This typically acts
as a strong regularizer.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.LocalizedLabelSmoother.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#LocalizedLabelSmoother.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.LocalizedLabelSmoother.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.LocalizedLabelSmoother.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>target_paddings</em>, <em>target_labels</em>, <em>target_ids</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#LocalizedLabelSmoother.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.LocalizedLabelSmoother.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert class_ids to 1hot and smooth by neighborhood.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>target_paddings</strong> – float32 matrix [bs, seq_len]</li>
<li><strong>target_labels</strong> – int32 matrix [bs, seq_len]. This stores the target label
output at each decoder step as generated by the speech input generator
input_batch.tgt.labels</li>
<li><strong>target_ids</strong> – int32 matrix [bs, seq_len]. This stores the target_id that is
fed to the decoder, as generated by the speech input generator
input_batch.tgt.ids</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tensor [bs, seq_len, num_classes] denoting a smoothed distribution over
num_classes.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.UniformLabelSmoother">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">UniformLabelSmoother</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#UniformLabelSmoother"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.UniformLabelSmoother" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Smooths labels given as class ids and confidence.</p>
<p>Implements the smoothing from <a class="reference external" href="https://arxiv.org/abs/1512.00567">https://arxiv.org/abs/1512.00567</a>. Correct class
label confidence is dropped by eps and all the other classes are increased
by eps/num_classes.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.UniformLabelSmoother.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#UniformLabelSmoother.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.UniformLabelSmoother.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.UniformLabelSmoother.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>target_paddings</em>, <em>target_labels</em>, <em>target_ids</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#UniformLabelSmoother.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.UniformLabelSmoother.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert target_labels to 1hot and smooth uniformly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>target_paddings</strong> – float32 matrix [bs, seq_len]</li>
<li><strong>target_labels</strong> – int32 matrix [bs, seq_len]. This stores the target label
output at each decoder step as generated by the speech input generator
input_batch.tgt.labels</li>
<li><strong>target_ids</strong> – int32 matrix [bs, seq_len]. This stores the target_id that is
fed to the decoder, as generated by the speech input generator
input_batch.tgt.ids</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tensor of float32 [bs, seq_len, num_classes] denoting a smoothed
distribution over num_classes.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.HighwaySkipLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">HighwaySkipLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#HighwaySkipLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.HighwaySkipLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>A highway skip layer.</p>
<p>This class represents a highway skip layer, which takes multiple
inputs (from different layers of the network) and gates them.
This returns C(x)x + T(x)h, initially biasing C to be open.
For some discussion about initialization please see:
Section 2.2 in [Srivastava, 2015]: <a class="reference external" href="https://arxiv.org/pdf/1505.00387v2.pdf">https://arxiv.org/pdf/1505.00387v2.pdf</a></p>
<dl class="classmethod">
<dt id="lingvo.core.layers.HighwaySkipLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#HighwaySkipLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.HighwaySkipLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.HighwaySkipLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>x</em>, <em>transformed_x</em>, <em>paddings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#HighwaySkipLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.HighwaySkipLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Fprop for Highway Skip layer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>x</strong> – feature at the lower layer.</li>
<li><strong>transformed_x</strong> – transformation of x at a higher layer.</li>
<li><strong>paddings</strong> – padding applied to the features.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">layer_out - activations after forward propagation.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.GradNormTracker">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">GradNormTracker</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#GradNormTracker"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.GradNormTracker" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>A helper class to keep track of gradient norm stats.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.GradNormTracker.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#GradNormTracker.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.GradNormTracker.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.GradNormTracker.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>grad_norm</em>, <em>has_nan=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#GradNormTracker.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.GradNormTracker.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Update gradient norm moving avgs, and returns whether or not …</p>
<p>to clip gradients to 0.0. If the current batch has NaN grads, does not
update the moving avgs and forces to clip the gradients to 0.0.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>grad_norm</strong> – A float scalar tensor.</li>
<li><strong>has_nan</strong> – A boolean scalar tensor to indicate if the current batch has nan.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A scalar float tensor with value of either 1.0 or 0.0. The value of 0.0
means the gradient norm is excessively large or contains NaN, and the step
should be aborted completely.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.WeightedSumLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">WeightedSumLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#WeightedSumLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.WeightedSumLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Returns the weighted sum of a list of input tensors.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.WeightedSumLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#WeightedSumLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.WeightedSumLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Params for this MergerLayer class.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.WeightedSumLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#WeightedSumLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.WeightedSumLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Combines the list of input tensors into a single tensor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>inputs</strong> – A list of tensors of shape [time, batch, hidden_dim]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tensor of the same shape with input tensors.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.GatedAverageLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">GatedAverageLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#GatedAverageLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.GatedAverageLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Gated combination of n input vectors.</p>
<p>Given n inputs, x_1 … x_n. First learns a gate g in a single layer.
Returns g_1 * x_1 + … g_n * x_n.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.GatedAverageLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#GatedAverageLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.GatedAverageLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.GatedAverageLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#GatedAverageLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.GatedAverageLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Gates, then merges a list of n input vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – gm (gate matrix)</li>
<li><strong>inputs</strong> – List of inputs, each of shape […, num_nodes]</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a gated output vector […, num_nodes]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.LHUCLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">LHUCLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#LHUCLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.LHUCLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Learning</span> <span class="pre">Hidden</span> <span class="pre">Unit</span> <span class="pre">Contribution</span> <span class="pre">(LHUC)</span></code> layer.</p>
<dl class="docutils">
<dt>This paper proposes to use LHUC layer for NMT adaptation:</dt>
<dd><a class="reference external" href="http://aclweb.org/anthology/N18-2080">http://aclweb.org/anthology/N18-2080</a></dd>
</dl>
<p>During base model training, LHUC layer is fixed to 1.0 (no-op in
multiplication). During adaptation, only LHUC layer is trained, and all other
parameters in the model are frozen.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.LHUCLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#LHUCLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.LHUCLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.LHUCLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inp</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#LHUCLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.LHUCLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Add learnt gate for adaptation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.ResidualAdapterLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">ResidualAdapterLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ResidualAdapterLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ResidualAdapterLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Residual Adapter layer for NLP tasks.</p>
<p>This paper proposes using residual adapters for fine-tuning new tasks on BERT.
<a class="reference external" href="https://arxiv.org/pdf/1902.00751.pdf">https://arxiv.org/pdf/1902.00751.pdf</a></p>
<p>During adaptation, residual adapter layers can be added to a pre-trained
model and trained, while all other parameters are frozen.
In terms of operations, the layer is identical to a vanilla Transformer
feedforward layer. Separate implementation is meant to distinguish function.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.ResidualAdapterLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ResidualAdapterLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ResidualAdapterLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.ResidualAdapterLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>x</em>, <em>paddings=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#ResidualAdapterLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.ResidualAdapterLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Fprop for Residual Adapter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this layer and
its children layers.</li>
<li><strong>x</strong> – […, input_dim].</li>
<li><strong>paddings</strong> – padding applied to the features.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">layer_out - […, input_dim].</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="lingvo.core.layers.Conv2DFlops">
<code class="descclassname">lingvo.core.layers.</code><code class="descname">Conv2DFlops</code><span class="sig-paren">(</span><em>inputs</em>, <em>filter_shape</em>, <em>stride</em>, <em>padding</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#Conv2DFlops"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.Conv2DFlops" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns number of float operations (mult/adds) for a Conv2D op.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>inputs</strong> – the input shape. Must have four elements.</li>
<li><strong>filter_shape</strong> – the convolution filter shape. Must have four elements.</li>
<li><strong>stride</strong> – the strides along height and width, respectively.</li>
<li><strong>padding</strong> – ‘SAME’ or ‘VALID’.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Number of multiplications and additions.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.Conv2DLayerNoPadding">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">Conv2DLayerNoPadding</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#Conv2DLayerNoPadding"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.Conv2DLayerNoPadding" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>2-D Convolution layer w/o padding.</p>
<p>TODO(laurenzo): Dedup in favor of SeparableConv2DLayer where possible.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.Conv2DLayerNoPadding.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#Conv2DLayerNoPadding.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.Conv2DLayerNoPadding.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.Conv2DLayerNoPadding._CreateConvVariables">
<code class="descname">_CreateConvVariables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#Conv2DLayerNoPadding._CreateConvVariables"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.Conv2DLayerNoPadding._CreateConvVariables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.Conv2DLayerNoPadding.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#Conv2DLayerNoPadding.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.Conv2DLayerNoPadding.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply convolution to inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A NestedMap object containing weights’ values of this layer and its
children layers.</li>
<li><strong>x</strong> – The inputs tensor. It is expected to be of shape [batch, height, width,
channel].</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Convolution output.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="lingvo.core.layers.Conv2DLayerNoPadding.FPropMeta">
<em class="property">classmethod </em><code class="descname">FPropMeta</code><span class="sig-paren">(</span><em>p</em>, <em>inputs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#Conv2DLayerNoPadding.FPropMeta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.Conv2DLayerNoPadding.FPropMeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns metadata about the <a class="reference internal" href="#lingvo.core.layers.Conv2DLayerNoPadding.FProp" title="lingvo.core.layers.Conv2DLayerNoPadding.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> computation for this layer.</p>
<p><strong>Experimental feature.</strong>
Don’t use or depend on it without consulting Lingvo authors.</p>
<p>E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">SomeComplexLayer</span><span class="o">.</span><span class="n">Params</span><span class="p">()</span>
<span class="n">meta</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="n">FPropMeta</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tshape</span><span class="o">.</span><span class="n">Shape</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">&#39;channels&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">meta.flops</span></code> gives an estimate count of floating point operations done by
one <a class="reference internal" href="#lingvo.core.layers.Conv2DLayerNoPadding.FProp" title="lingvo.core.layers.Conv2DLayerNoPadding.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> given an input tensor of shape [128, 20, 50, channels].
<code class="xref py py-obj docutils literal notranslate"><span class="pre">meta.out_shapes</span></code> is a tuple of TShape, which tells you what shape
of tensors this layer will return.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>params</strong> – The param of a layer of this layer type.</li>
<li><strong>*args</strong> – Corresponds to FProp with Tensors replaced by <code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorShape</span></code>.</li>
<li><strong>**kwargs</strong> – Corresponds to FProp with Tensors replaced by <code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorShape</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> with</p>
<ul class="simple">
<li>flops - The estimated number of floating point operations incurred by
this fprop.</li>
<li>out_shapes - A tuple of <code class="xref py py-obj docutils literal notranslate"><span class="pre">TShape</span></code>. I.e., <code class="xref py py-obj docutils literal notranslate"><span class="pre">out_shapes[i]</span></code>
represents the shape of the <code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code>-th returned tensor of the fprop.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.FetchLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">FetchLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#FetchLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.FetchLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>A layer facilitating fetching activations and their gradients.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.FetchLayer.FPropMeta">
<em class="property">classmethod </em><code class="descname">FPropMeta</code><span class="sig-paren">(</span><em>params</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#FetchLayer.FPropMeta"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.FetchLayer.FPropMeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns metadata about the <a class="reference internal" href="#lingvo.core.layers.FetchLayer.FProp" title="lingvo.core.layers.FetchLayer.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> computation for this layer.</p>
<p><strong>Experimental feature.</strong>
Don’t use or depend on it without consulting Lingvo authors.</p>
<p>E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">SomeComplexLayer</span><span class="o">.</span><span class="n">Params</span><span class="p">()</span>
<span class="n">meta</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="n">FPropMeta</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tshape</span><span class="o">.</span><span class="n">Shape</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="s1">&#39;channels&#39;</span><span class="p">]))</span>
</pre></div>
</div>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">meta.flops</span></code> gives an estimate count of floating point operations done by
one <a class="reference internal" href="#lingvo.core.layers.FetchLayer.FProp" title="lingvo.core.layers.FetchLayer.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> given an input tensor of shape [128, 20, 50, channels].
<code class="xref py py-obj docutils literal notranslate"><span class="pre">meta.out_shapes</span></code> is a tuple of TShape, which tells you what shape
of tensors this layer will return.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>params</strong> – The param of a layer of this layer type.</li>
<li><strong>*args</strong> – Corresponds to FProp with Tensors replaced by <code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorShape</span></code>.</li>
<li><strong>**kwargs</strong> – Corresponds to FProp with Tensors replaced by <code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorShape</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> with</p>
<ul class="simple">
<li>flops - The estimated number of floating point operations incurred by
this fprop.</li>
<li>out_shapes - A tuple of <code class="xref py py-obj docutils literal notranslate"><span class="pre">TShape</span></code>. I.e., <code class="xref py py-obj docutils literal notranslate"><span class="pre">out_shapes[i]</span></code>
represents the shape of the <code class="xref py py-obj docutils literal notranslate"><span class="pre">i</span></code>-th returned tensor of the fprop.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.FetchLayer._ReturnSingleValueOrList">
<code class="descname">_ReturnSingleValueOrList</code><span class="sig-paren">(</span><em>lst</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#FetchLayer._ReturnSingleValueOrList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.FetchLayer._ReturnSingleValueOrList" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.FetchLayer.activation">
<code class="descname">activation</code><a class="headerlink" href="#lingvo.core.layers.FetchLayer.activation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="lingvo.core.layers.FetchLayer.gradient">
<code class="descname">gradient</code><a class="headerlink" href="#lingvo.core.layers.FetchLayer.gradient" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.FetchLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#FetchLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.FetchLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward propagation.</p>
<p>The central interface that subclasses should implement. The caller
calls <a class="reference internal" href="#lingvo.core.layers.FetchLayer.FProp" title="lingvo.core.layers.FetchLayer.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> with a <code class="xref py py-obj docutils literal notranslate"><span class="pre">theta</span></code> dictionary. E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span> <span class="o">=</span> <span class="n">InstanceOfASubClassOfFoo</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>The implementation of <a class="reference internal" href="#lingvo.core.layers.FetchLayer.FProp" title="lingvo.core.layers.FetchLayer.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp()</span></code></a> computes a function given
the theta and the inputs. E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">subs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
<span class="n">inputs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">a0</span> <span class="o">=</span> <span class="n">subs</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">linear</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">subs</span><span class="o">.</span><span class="n">softmax</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">softmax</span><span class="p">,</span> <span class="n">a0</span><span class="p">)</span>
<span class="c1"># The same layer applied twice.</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">subs</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">linear</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
<span class="k">return</span> <span class="n">a2</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this
layer and its children layers.</li>
<li><strong>*args</strong> – List args.</li>
<li><strong>**kwargs</strong> – Keyward args.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.GluLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">GluLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#GluLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.GluLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Gated Linear Unit.</p>
<p>See <a class="reference external" href="https://arxiv.org/abs/1612.08083">https://arxiv.org/abs/1612.08083</a> for more details.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.GluLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#GluLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.GluLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.GluLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>paddings</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#GluLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.GluLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward propagation.</p>
<p>The central interface that subclasses should implement. The caller
calls <a class="reference internal" href="#lingvo.core.layers.GluLayer.FProp" title="lingvo.core.layers.GluLayer.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp</span></code></a> with a <code class="xref py py-obj docutils literal notranslate"><span class="pre">theta</span></code> dictionary. E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foo</span> <span class="o">=</span> <span class="n">InstanceOfASubClassOfFoo</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">foo</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">foo</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>The implementation of <a class="reference internal" href="#lingvo.core.layers.GluLayer.FProp" title="lingvo.core.layers.GluLayer.FProp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FProp()</span></code></a> computes a function given
the theta and the inputs. E.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">subs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span>
<span class="n">inputs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">a0</span> <span class="o">=</span> <span class="n">subs</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">linear</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">subs</span><span class="o">.</span><span class="n">softmax</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">softmax</span><span class="p">,</span> <span class="n">a0</span><span class="p">)</span>
<span class="c1"># The same layer applied twice.</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">subs</span><span class="o">.</span><span class="n">linear</span><span class="o">.</span><span class="n">FProp</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">linear</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
<span class="k">return</span> <span class="n">a2</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>theta</strong> – A <a class="reference internal" href="lingvo.core.py_utils.html#lingvo.core.py_utils.NestedMap" title="lingvo.core.py_utils.NestedMap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">NestedMap</span></code></a> object containing weights’ values of this
layer and its children layers.</li>
<li><strong>*args</strong> – List args.</li>
<li><strong>**kwargs</strong> – Keyward args.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="lingvo.core.layers.MultitaskAdapterLayer">
<em class="property">class </em><code class="descclassname">lingvo.core.layers.</code><code class="descname">MultitaskAdapterLayer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#MultitaskAdapterLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.MultitaskAdapterLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="lingvo.core.base_layer.html#lingvo.core.base_layer.BaseLayer" title="lingvo.core.base_layer.BaseLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">lingvo.core.base_layer.BaseLayer</span></code></a></p>
<p>Residual adapter layer for multilingual models.</p>
<p>Residual adapters can be used to fine-tune a single model to multiple
domains, tasks, or languages: <a class="reference external" href="https://arxiv.org/pdf/1902.00751.pdf">https://arxiv.org/pdf/1902.00751.pdf</a>
For simplicity we refer only to languages here.</p>
<p>Each adapter consists of a “down” projection to a smaller dimension followed
by an “up” projection, the result of which is added back to the input
activation.  The projection weights and biases are language-specific.</p>
<p>Whereas lingvo_layers.ResidualAdapterLayer learns and applies the parameters
for a single language, this layer learns and applies the parameters for
multiple languages so that we have a single model serving the different
languages. The parameters can be trained for all languages at the same time,
or in one-off per-language training jobs.</p>
<dl class="classmethod">
<dt id="lingvo.core.layers.MultitaskAdapterLayer.Params">
<em class="property">classmethod </em><code class="descname">Params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#MultitaskAdapterLayer.Params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.MultitaskAdapterLayer.Params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the layer params.</p>
</dd></dl>

<dl class="method">
<dt id="lingvo.core.layers.MultitaskAdapterLayer.FProp">
<code class="descname">FProp</code><span class="sig-paren">(</span><em>theta</em>, <em>inputs</em>, <em>langs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/lingvo/core/layers.html#MultitaskAdapterLayer.FProp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#lingvo.core.layers.MultitaskAdapterLayer.FProp" title="Permalink to this definition">¶</a></dt>
<dd><p>Fprop for multilingual adapter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>theta</strong> – A NestedMap object containing weights’ values of this layer and its
children layers.</li>
<li><strong>inputs</strong> – A tensor containing the activations from the previous layer of
shape [time, batch, input_dim].</li>
<li><strong>langs</strong> – An int32 tensor containing the language ID for each input.  If
‘langs’ is of rank 2, we assume it to be of shape [time, batch],
indicating a different language for each timestep.  In this case we look
up adapter params for each timestep.  If ‘langs’ is of rank 1, we assume
it to be of shape [batch], indicating a single language for all
timesteps of a sequence.  This latter setup uses substantially less
memory and is generally preferred.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>A tensor containing the adapted activations with shape</dt>
<dd><p class="first last">[time, batch, input_dim].</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">output</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="lingvo.core.layers_with_attention.html" class="btn btn-neutral float-right" title="lingvo.core.layers_with_attention module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="lingvo.core.insertion.html" class="btn btn-neutral float-left" title="lingvo.core.insertion module" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>